编译
    ./configure --enable-debug --enable-cassert --enable-thread-safety --prefix=/Users/a/program/pg12 CFLAGS="-g -O0 -std=c99 -Wno-declaration-after-statement"

    make -sj
其他
  SELECT pg_backend_pid();

  PlannerInfo* root
  Plan* top_plan
  PlannedStmt* result

  ./postgres -D ../data
  ./psql postgres


create table test_table
(
    addr varchar(255)
);

create table row_table
(
    id   integer not null
        constraint pk_row_table
            primary key,
    addr varchar(255),
    a    varchar,
    sale integer
);
create index index_sale_row_table    on row_table (sale);



  explain select * from row_table where id=1 and sale=1;

  INSERT INTO row_table (id, addr,a,sale) SELECT d, 'a','a',d FROM generate_series(1,20000) d;
  insert into test_table (addr) values ('addr');

  select * from test_table LEFT JOIN row_table on test_table.addr = row_table.addr;

  select * from test_table, row_table where test_table.addr = row_table.addr;

data/global/pg_contorl内容是ControlFileData二进制
    详见 ReadControlFile

data/PG_VESION记录了pg的大小版本
    详见 ValidatePgVersion

data/postmaster.pid
    是DataDirLockFile
    内容的格式 详见CreateDataDirLockFile
         pid
         data目录
         启动时间
         port
         localsocket 地址
         localsock地址
         不知
         当前的状态
            #define PM_STATUS_STARTING		"starting"
            #define PM_STATUS_STOPPING		"stopping"
            #define PM_STATUS_READY			"ready   "
            #define PM_STATUS_STANDBY		"standby "

         以下是各行为什么是对应相应数据的原因
         #define LOCK_FILE_LINE_PID			1
         #define LOCK_FILE_LINE_DATA_DIR		2
         #define LOCK_FILE_LINE_START_TIME	3
         #define LOCK_FILE_LINE_PORT			4
         #define LOCK_FILE_LINE_SOCKET_DIR	5
         #define LOCK_FILE_LINE_LISTEN_ADDR	6
         #define LOCK_FILE_LINE_SHMEM_KEY	7
         #define LOCK_FILE_LINE_PM_STATUS	8


data/postermaster.opts 内容是启动的命令
    详见 CreateOptsFile

fsync用到的F_FULLFSYNC是mac专有 pg_fsync


palloc分配的最大值
    #define MaxAllocSize	((Size) 0x3fffffff) /* 1 gigabyte - 1 */
    #define AllocSizeIsValid(size)	((Size) (size) <= MaxAllocSize)

使用AllocateFile来open文件

内存的分配函数指针的集合
    static const MemoryContextMethods AllocSetMethods = {
    	AllocSetAlloc,
    	AllocSetFree,
    	AllocSetRealloc,
    	AllocSetReset,
    	AllocSetDelete,
    	AllocSetGetChunkSpace,
    	AllocSetIsEmpty,
    	AllocSetStats
    #ifdef MEMORY_CONTEXT_CHECKING
    	,AllocSetCheck
    #endif
    };

c的list实现
    lappend 函数
    foreach 宏

load library
    internal_load_library

inode维度来确认是不是同个文件
    internal_load_library中用到的宏 SAME_INODE

extension中的_PG_init调用
    internal_load_library中会通过dlsym得到函数的指针然后调用

extension中PG_MODULE_MAGIC意义
    PG_MAGIC_FUNCTION_NAME Pg_magic_func
    internal_load_library中通过dlsym得到Pg_magic_func函数

repalloc中有意思的 GetMemoryChunkContext
    根据裸指针得到隶属的memory context
        context = *(MemoryContext *) (((char *) pointer) - sizeof(void *));
        AllocChunkData的最后个原始便是 void* allocSet 是不是意味着实际数据是直接在这个指针之后的


通过了不断使用dup(0)用掉了fd来知道当前有多少可用的fd
    详见 count_usable_fds

编译器内置函数__builtin_frame_address
    详见 set_stack_base

使用了pipe来让子进程来感知主进程的消亡
    InitPostmasterDeathWatchHandle



单个的客户端的连接对应1个子进程
    BackendStartup

通过signal_child可以知道
    进程组id(pgid)是组长进程的pid
    setsid 用来把当前的进程的设置为进程组的组长
    kill -进程组id 用来把组内的全部都干掉

子进程在ps中显示的名字 postgres: a postgres 127.0.0.1(60240) idle
    详见 init_ps_display

c语言中的各个种类的最大值
/* C90/99 5.2.4.2.1 */
#define SCHAR_MAX __SCHAR_MAX__
#define SHRT_MAX  __SHRT_MAX__
#define INT_MAX   __INT_MAX__
#define LONG_MAX  __LONG_MAX__


foreach宏本质是对链表list遍历


GetRelationPath描述了数据目录下表的数据的路径结构

重要的文件
data/PG_VERSION 内容是pg的版本号
data/global/pg_control ControlFileData二进制内容
data/postmaster.pid
data/postermaster.opts 内容是启动的命令
    详见 CreateOptsFile

得到当前的函数的名字
    得到当前函数的oid再得到名字

    (psprintf("%s()", fcinfo->flinfo ? get_func_name(FC_FN_OID(fcinfo)) : __func__))


如何在程序的维度遍历扫描
   详见timescaledb的 hypertable_validate_constraints() , relation_has_tuples()

正常的表都是日志型的
    static bool table_is_logged(Oid tableRelid) {
    	return get_rel_persistence(tableRelid) == RELPERSISTENCE_PERMANENT;
    }

共享内存
    sql: select name, setting from pg_settings where name like 'shared_memory_type';
    global变量: int shared_memory_type
    typedef enum
    {
    	SHMEM_TYPE_WINDOWS,
    	SHMEM_TYPE_SYSV,
    	SHMEM_TYPE_MMAP // 默认
    }			PGShmemType;
动态共享内存 https://blog.csdn.net/asmartkiller/article/details/118656910
    使用shm_open()得到在/dev/shm 下的fd
    使用 ftruncate(fd, size)调整到期望的大小
    使用mmap对该fd映射

    dynamic shared memory 用在 并行查询 是9.6之后有的
    对于并行查询而言，执行时创建的 worker 进程与 leader 进程通过共享内存实现数据交互。
    然而这部分内存无法像普通的共享内存那样在系统启动时预先分配，直到真正执行时才知道有多少 worker 进程，以及需要分配多少内存。
    动态共享内存，即在执行时动态创建，用于 leader 与 worker 间通信，执行完成后release

    sql: select name, setting from pg_settings where name like 'dynamic_shared_memory_type';

    global变量:int dynamic_shared_memory_type;
    /* Dynamic shared memory implementations. */
    #define DSM_IMPL_POSIX			1 // 默认
    #define DSM_IMPL_SYSV			2
    #define DSM_IMPL_WINDOWS		3
    #define DSM_IMPL_MMAP			4


LWLock(light weight lock)

pg 有多个 semaphore set ,每个集合下有 SEMAS_PER_SET(16) 个信号量 ,PGSemaphoreCreate()






spin等锁
    perform_spin_delay()
    套路还是熟悉的 首先死循环 到了趟数之后sleep 然后再死循环 然后sleep 休眠的时间也会逐步上升 休眠是用select实现


表对应的数据文件
    之前知道已知道pg中最小的粒度单元是 block 大小是 BLCKSZ
    某个的表对应的数据文件的单个的大小也是有限制的 最大可以容纳 RELSEG_SIZE 个block
    这样的1个单元称为segment
    要是了某个表的数据很大 单个的segment 已经容纳不下了 那么对应多个segment文件
    第1的个segment名字是"表的oid" 第2的个segment名字是"表的oid.1" 对应_mdfd_segpath()函数



    要是要找的数据在很后边的话要越过多个segment貌似不能直接定位到那个部分 还是要顺序的

临时目录和文件的path规则
    OpenTempFileInTablespace()函数用到了以下的2个
     // 得到指明的表空间下的临时目录的path
     TempTablespacePath(tempDirPath, tblspcOid);

     // Generate a tempfile name that should be unique within the current database instance.
     snprintf(tempFilePath, sizeof(tempFilePath), "%s/%s%d.%ld",
              tempDirPath, PG_TEMP_FILE_PREFIX, MyProcPid, tempFileCounter++);


单个的临时文件的大小上限是 MAX_PHYSICAL_FILESIZE


tid(tuple id)指的是 ItemPointerData,能够直接定位到table的某条data
index某种意义上和普通的数据表相同 1个个的index的数据和表的单条数据相同 也是以tuple的形式保存落地
普通的表对应的是 heapTuple, index对应的是 indexTuple ,其主体内容是上述的tid
typedef struct IndexTupleData {

    // 实际的data位置,reference TID to heap tuple
    ItemPointerData t_tid;

    /*
     * various info about tuple
     *
     * 15th (high) bit: has nulls
     * 14th bit: has var-width attributes
     * 13th bit: AM-defined meaning
     * 12-0 bit: size of tuple
     */
    unsigned short t_info;

} IndexTupleData;                /* MORE DATA FOLLOWS AT END OF STRUCT */
typedef IndexTupleData *IndexTuple;

如何应对1个单column的index
如何应对过个单column的index
如何应对1个多column的index
如何应对多个多column的index

indexRelation的第0个buffer是meta
    Buffer metaBuffer = _bt_getbuf(indexRelation, BTREE_METAPAGE, BT_READ);
indexRelation的meta对应的那个page实际保存的数据便是meta本身
    Page metaPage = BufferGetPage(metaBuffer);
    BTMetaPageData *btMetaPageData = BTPageGetMeta(metaPage);
indexRelation上的各个page都含BTPageOpaque

    indexPage = BufferGetPage(indexBuffer);
    btPageOpaque = (BTPageOpaque) PageGetSpecialPointer(indexPage);




hash structure
    hashJoin
        hash  对应 inner表 test_table
            seqScan
        seqScan 对应 outer表 row_table

    outer表上得到1行data后会到

由timescaledb来的知识
    insert into test_table values ('a') 对应的plan是 modifyTable
    它的小弟位于 List *plans属性 通常是 result的plan(是这个plan是result) 对应 sql的 'a'


#define BufferGetPage(buffer) ((Page)BufferGetBlock(buffer))
    Block是void*指针 page是pointer  对应 整个的block起点 该起点也是 pageHeader起点


话术上的对应
    wal对应xlog ,clog对应xact

lsn: Log sequence number
    https://blog.csdn.net/weixin_39540651/article/details/117021173


wal(xlog)的文件名规则
    详细的逻辑 XLogFilePath()
    pg_wal目录 文件的名字是3个8位的数字构成的